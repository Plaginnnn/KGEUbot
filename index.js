import axios from 'axios'
import { Markup, Telegraf, session } from 'telegraf'

const token = '7415179094:AAHyPLljfNicW5Kn_owAqbwmOhz5tnyn7wA'
const bot = new Telegraf(token)

bot.use(session())

const users = new Map()
let scheduleCache = new Map()

const createMainMenu = (isAuthenticated, userName = '') => {
	const buttons = [
		['üåê –ù–∞—à–∏ —Å–æ—Ü. —Å–µ—Ç–∏'],
		['üîî –í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è'],
		['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ'],
	]

	if (isAuthenticated) {
		buttons.unshift([`üë§ ${userName}`, 'üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ'])
	} else {
		buttons.unshift(['üîê –í–æ–π—Ç–∏'])
	}

	return Markup.keyboard(buttons).resize()
}

const createScheduleMenu = Markup.keyboard([
	['–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞'],
	['–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Ç–µ–∫—É—â—É—é –Ω–µ–¥–µ–ª—é'],
	['–ö–∞–ª–µ–Ω–¥–∞—Ä—å'],
	['–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é'],
]).resize()

const deleteAllPreviousMessages = async ctx => {
	if (ctx.chat && ctx.message) {
		const currentMessageId = ctx.message.message_id
		for (let i = currentMessageId - 1; i > 0; i--) {
			try {
				await ctx.deleteMessage(i)
			} catch (error) {
				if (error.description !== 'Bad Request: message to delete not found') {
					console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:', error)
				}
				break
			}
		}
	}
}

const initSession = (ctx, next) => {
	if (!ctx.session) {
		ctx.session = {}
	}
	return next()
}

bot.use(initSession)

const authMiddleware = (ctx, next) => {
	const userId = ctx.from.id
	if (users.has(userId)) {
		ctx.state.user = users.get(userId)
		return next()
	}
	ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–∫–∏ "üîê –í–æ–π—Ç–∏"')
}

const getShortName = (lastName, firstName, parentName) => {
	return `${lastName} ${firstName[0]}.${parentName[0]}.`
}

const fetchSchedule = async (token, week) => {
	try {
		const response = await axios.get(
			`https://iep.kgeu.ru/api/schedule${week ? `?week=${week}` : ''}`,
			{
				headers: { 'x-access-token': token },
			}
		)
		return response.data.payload
	} catch (error) {
		console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è:', error)
		return null
	}
}

const cacheAllSchedules = async token => {
	for (let week = 1; week <= 30; week++) {
		const schedule = await fetchSchedule(token, week)
		if (schedule && schedule.schedules.length > 0) {
			schedule.schedules.forEach(item => {
				const date = new Date(item.date).toISOString().split('T')[0]
				scheduleCache.set(date, item)
			})
		}
	}
}

const formatDate = dateString => {
	const date = new Date(dateString)
	return date.toLocaleDateString('ru-RU', {
		day: '2-digit',
		month: '2-digit',
		year: 'numeric',
	})
}

const getDayOfWeek = dateString => {
	const date = new Date(dateString)
	const days = [
		'–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ',
		'–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫',
		'–≤—Ç–æ—Ä–Ω–∏–∫',
		'—Å—Ä–µ–¥–∞',
		'—á–µ—Ç–≤–µ—Ä–≥',
		'–ø—è—Ç–Ω–∏—Ü–∞',
		'—Å—É–±–±–æ—Ç–∞',
	]
	return days[date.getDay()]
}

const formatScheduleMessage = schedules => {
	if (schedules.length === 0) {
		return '–ù–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –Ω–µ—Ç.'
	}

	return schedules
		.map(item => {
			const date = formatDate(item.date)
			const dayOfWeek = getDayOfWeek(item.date)
			return `–î–∞—Ç–∞: ${date} (${dayOfWeek})
–í—Ä–µ–º—è: ${item.timeStart} - ${item.timeEnd}
–ü—Ä–µ–¥–º–µ—Ç: ${item.discip.name}
–¢–∏–ø: ${item.type.name}
–ê—É–¥–∏—Ç–æ—Ä–∏—è: ${item.auiditory}
–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å: ${item.teacher.name}
-------------------`
		})
		.join('\n')
}

bot.command('start', async ctx => {
	await deleteAllPreviousMessages(ctx)
	const userId = ctx.from.id
	const isAuthenticated = users.has(userId)
	const mainMenu = createMainMenu(
		isAuthenticated,
		isAuthenticated
			? getShortName(
					users.get(userId).userData.LastName,
					users.get(userId).userData.FirstName,
					users.get(userId).userData.ParentName
			  )
			: ''
	)
	await ctx.reply('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:', mainMenu)
})

bot.hears(/üë§ .+/, authMiddleware, async ctx => {
	await deleteAllPreviousMessages(ctx)
	const userData = ctx.state.user.userData
	await ctx.reply(
		`–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å:
–ò–º—è: ${userData.FirstName}
–§–∞–º–∏–ª–∏—è: ${userData.LastName}
–û—Ç—á–µ—Å—Ç–≤–æ: ${userData.ParentName}
Email: ${userData.EMail}
–î–æ–ª–∂–Ω–æ—Å—Ç—å: ${userData.Position}`,
		createMainMenu(
			true,
			getShortName(userData.LastName, userData.FirstName, userData.ParentName)
		)
	)
})

bot.hears('üîê –í–æ–π—Ç–∏', async ctx => {
	await deleteAllPreviousMessages(ctx)
	await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –ª–æ–≥–∏–Ω:')
	ctx.session.state = 'awaitingLogin'
})

bot.hears('üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', authMiddleware, async ctx => {
	await deleteAllPreviousMessages(ctx)
	await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è:', createScheduleMenu)
})

bot.hears('–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞', authMiddleware, async ctx => {
	const token = ctx.state.user.token
	const tomorrow = new Date()
	tomorrow.setDate(tomorrow.getDate() + 1)
	const tomorrowStr = tomorrow.toISOString().split('T')[0]

	if (scheduleCache.size === 0) {
		await ctx.reply('–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è...')
		await cacheAllSchedules(token)
	}

	const schedule = scheduleCache.get(tomorrowStr)
	if (schedule) {
		await ctx.reply(formatScheduleMessage([schedule]))
	} else {
		await ctx.reply('–ù–∞ –∑–∞–≤—Ç—Ä–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –Ω–µ—Ç.')
	}
})

bot.hears('–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Ç–µ–∫—É—â—É—é –Ω–µ–¥–µ–ª—é', authMiddleware, async ctx => {
	const token = ctx.state.user.token
	const schedule = await fetchSchedule(token)
	if (schedule) {
		await ctx.reply(formatScheduleMessage(schedule.schedules))
	} else {
		await ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Ç–µ–∫—É—â—É—é –Ω–µ–¥–µ–ª—é.')
	}
})

bot.hears('–ö–∞–ª–µ–Ω–¥–∞—Ä—å', authMiddleware, async ctx => {
	await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì:')
	ctx.session.state = 'awaitingDate'
})

bot.hears('–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', async ctx => {
	const userId = ctx.from.id
	const isAuthenticated = users.has(userId)
	const mainMenu = createMainMenu(
		isAuthenticated,
		isAuthenticated
			? getShortName(
					users.get(userId).userData.LastName,
					users.get(userId).userData.FirstName,
					users.get(userId).userData.ParentName
			  )
			: ''
	)
	await ctx.reply('–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:', mainMenu)
})

bot.hears('üåê –ù–∞—à–∏ —Å–æ—Ü. —Å–µ—Ç–∏', async ctx => {
	await deleteAllPreviousMessages(ctx)
	const userId = ctx.from.id
	const isAuthenticated = users.has(userId)
	const mainMenu = createMainMenu(
		isAuthenticated,
		isAuthenticated
			? getShortName(
					users.get(userId).userData.LastName,
					users.get(userId).userData.FirstName,
					users.get(userId).userData.ParentName
			  )
			: ''
	)
	await ctx.reply('–ù–∞—à–∏ —Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–µ—Ç–∏:', mainMenu)
})

bot.hears('üîî –í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è', async ctx => {
	await deleteAllPreviousMessages(ctx)
	const userId = ctx.from.id
	const isAuthenticated = users.has(userId)
	const mainMenu = createMainMenu(
		isAuthenticated,
		isAuthenticated
			? getShortName(
					users.get(userId).userData.LastName,
					users.get(userId).userData.FirstName,
					users.get(userId).userData.ParentName
			  )
			: ''
	)
	await ctx.reply('–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã', mainMenu)
})

bot.hears('‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ', async ctx => {
	await deleteAllPreviousMessages(ctx)
	const userId = ctx.from.id
	const isAuthenticated = users.has(userId)
	const mainMenu = createMainMenu(
		isAuthenticated,
		isAuthenticated
			? getShortName(
					users.get(userId).userData.LastName,
					users.get(userId).userData.FirstName,
					users.get(userId).userData.ParentName
			  )
			: ''
	)
	await ctx.reply(
		'–≠—Ç–æ—Ç –±–æ—Ç –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏ –ö–ì–≠–£.',
		mainMenu
	)
})

bot.on('text', async ctx => {
	await deleteAllPreviousMessages(ctx)

	const userId = ctx.from.id

	switch (ctx.session.state) {
		case 'awaitingLogin':
			ctx.session.login = ctx.message.text
			await ctx.reply('–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –ø–∞—Ä–æ–ª—å:')
			ctx.session.state = 'awaitingPassword'
			break
		case 'awaitingPassword':
			const { login } = ctx.session
			const password = ctx.message.text

			try {
				const response = await axios.get(`https://iep.kgeu.ru/api/auth`, {
					params: { login, password },
				})

				if (response.data.type === 'success') {
					const { token, userData } = response.data.payload
					users.set(userId, { login, token, userData })
					const shortName = getShortName(
						userData.LastName,
						userData.FirstName,
						userData.ParentName
					)
					await ctx.reply(
						`–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, ${userData.LastName} ${userData.FirstName} ${userData.ParentName}! –í—ã —É—Å–ø–µ—à–Ω–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.`,
						createMainMenu(true, shortName)
					)
					await cacheAllSchedules(token)
				} else {
					await ctx.reply(
						'–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.',
						createMainMenu(false)
					)
				}
			} catch (error) {
				console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:', error)
				await ctx.reply(
					'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏. –í–≤–µ–¥–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ',
					createMainMenu(false)
				)
			}

			delete ctx.session.state
			delete ctx.session.login
			break
		case 'awaitingDate':
			const dateInput = ctx.message.text
			const [day, month, year] = dateInput.split('.').map(Number)
			const date = new Date(year, month - 1, day)
			if (!isNaN(date.getTime())) {
				const formattedDate = date.toISOString().split('T')[0]
				const schedule = scheduleCache.get(formattedDate)
				if (schedule) {
					await ctx.reply(formatScheduleMessage([schedule]))
				} else {
					await ctx.reply('–ù–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –Ω–µ—Ç.')
				}
			} else {
				await ctx.reply(
					'–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì.'
				)
			}
			delete ctx.session.state
			break
		default:
			await ctx.reply(
				'–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ–Ω—é –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –±–æ—Ç–æ–º.',
				createMainMenu(
					users.has(userId),
					users.has(userId)
						? getShortName(
								users.get(userId).userData.LastName,
								users.get(userId).userData.FirstName,
								users.get(userId).userData.ParentName
						  )
						: ''
				)
			)
	}
})

bot.catch((err, ctx) => {
	console.error(`–û—à–∏–±–∫–∞ –¥–ª—è ${ctx.updateType}`, err)
	const userId = ctx.from.id
	const isAuthenticated = users.has(userId)
	const mainMenu = createMainMenu(
		isAuthenticated,
		isAuthenticated
			? getShortName(
					users.get(userId).userData.LastName,
					users.get(userId).userData.FirstName,
					users.get(userId).userData.ParentName
			  )
			: ''
	)
	ctx.reply(
		'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.',
		mainMenu
	)
})

bot.launch()

process.once('SIGINT', () => bot.stop('SIGINT'))
process.once('SIGTERM', () => bot.stop('SIGTERM'))
